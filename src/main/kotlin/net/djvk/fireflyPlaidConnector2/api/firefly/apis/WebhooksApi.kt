/**
 * Firefly III API v1.5.6
 *
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2022-04-04T03:54:41+00:00
 *
 * The version of the OpenAPI document: 1.5.6
 * Contact: james@firefly-iii.org
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package net.djvk.fireflyPlaidConnector2.api.firefly.apis

import com.fasterxml.jackson.databind.ObjectMapper
import io.ktor.client.*
import io.ktor.client.engine.*
import net.djvk.fireflyPlaidConnector2.api.firefly.infrastructure.*
import net.djvk.fireflyPlaidConnector2.api.firefly.models.*
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Component

@Component
open class WebhooksApi(
    @Value("\${fireflyPlaidConnector2.firefly.url}")
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonBlock: ObjectMapper.() -> Unit = ApiClient.JSON_DEFAULT,
) : ApiClient(baseUrl, httpClientEngine, httpClientConfig, jsonBlock) {

    /**
     * Delete a webhook.
     * Delete a webhook.
     * @param id The webhook ID.
     * @return void
     */
    open suspend fun deleteWebhook(id: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/v1/webhooks/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Delete a webhook message.
     * Delete a webhook message. Any time a webhook is triggered the message is stored before it&#39;s sent. You can delete them before or after sending.
     * @param id The webhook ID.
     * @param messageId The webhook message ID.
     * @return void
     */
    open suspend fun deleteWebhookMessage(id: kotlin.String, messageId: kotlin.Int): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/v1/webhooks/{id}/messages/{messageId}".replace("{" + "id" + "}", "$id")
                .replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Delete a webhook attempt.
     * Delete a webhook message attempt. If you delete all attempts for a webhook message, Firefly III will (once again) assume all is well with the webhook message and will try to send it again.
     * @param id The webhook ID.
     * @param messageId The webhook message ID.
     * @param attemptId The webhook message attempt ID.
     * @return void
     */
    open suspend fun deleteWebhookMessageAttempt(
        id: kotlin.String,
        messageId: kotlin.Int,
        attemptId: kotlin.Int
    ): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/api/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}".replace("{" + "id" + "}", "$id")
                .replace("{" + "messageId" + "}", "$messageId").replace("{" + "attemptId" + "}", "$attemptId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Get a single message from a webhook.
     * When a webhook is triggered it will store the actual content of the webhook in a webhook message. You can view and analyse a single one using this endpoint.
     * @param id The webhook ID.
     * @param messageId The webhook message ID.
     * @return WebhookMessageSingle
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSingleWebhookMessage(
        id: kotlin.String,
        messageId: kotlin.Int
    ): HttpResponse<WebhookMessageSingle> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/webhooks/{id}/messages/{messageId}".replace("{" + "id" + "}", "$id")
                .replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Get a single failed attempt from a single webhook message.
     * When a webhook message fails to send it will store the failure in an \&quot;attempt\&quot;. You can view and analyse these. Webhooks messages that receive too many attempts (failures) will not be fired. You must first clear out old attempts and try again. This endpoint shows you the details of a single attempt. The ID of the attempt must match the corresponding webhook and webhook message.
     * @param id The webhook ID.
     * @param messageId The webhook message ID.
     * @param attemptId The webhook attempt ID.
     * @return WebhookAttemptSingle
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSingleWebhookMessageAttempt(
        id: kotlin.String,
        messageId: kotlin.Int,
        attemptId: kotlin.Int
    ): HttpResponse<WebhookAttemptSingle> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/webhooks/{id}/messages/{messageId}/attempts/{attemptId}".replace("{" + "id" + "}", "$id")
                .replace("{" + "messageId" + "}", "$messageId").replace("{" + "attemptId" + "}", "$attemptId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Get a single webhook.
     * Gets all info of a single webhook.
     * @param id The webhook ID.
     * @return WebhookSingle
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getWebhook(id: kotlin.String): HttpResponse<WebhookSingle> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/webhooks/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Get all the failed attempts of a single webhook message.
     * When a webhook message fails to send it will store the failure in an \&quot;attempt\&quot;. You can view and analyse these. Webhook messages that receive too many attempts (failures) will not be sent again. You must first clear out old attempts before the message can go out again.
     * @param id The webhook ID.
     * @param messageId The webhook message ID.
     * @param page Page number. The default pagination is per 50 items. (optional)
     * @return WebhookAttemptArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getWebhookMessageAttempts(
        id: kotlin.String,
        messageId: kotlin.Int,
        page: kotlin.Int?
    ): HttpResponse<WebhookAttemptArray> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/webhooks/{id}/messages/{messageId}/attempts".replace("{" + "id" + "}", "$id")
                .replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Get all the messages of a single webhook.
     * When a webhook is triggered the actual message that will be send is stored in a \&quot;message\&quot;. You can view and analyse these messages.
     * @param id The webhook ID.
     * @return WebhookMessageArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getWebhookMessages(id: kotlin.String): HttpResponse<WebhookMessageArray> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/webhooks/{id}/messages".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * List all webhooks.
     * List all the user&#39;s webhooks.
     * @param page The page number, if necessary. The default pagination is 50, so 50 webhooks per page. (optional)
     * @return WebhookArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listWebhook(page: kotlin.Int?): HttpResponse<WebhookArray> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/api/v1/webhooks",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Store a new webhook
     * Creates a new webhook. The data required can be submitted as a JSON body or as a list of parameters. The webhook will be given a random secret.
     * @param webhookStore JSON array or key&#x3D;value pairs with the necessary webhook information. See the model for the exact specifications.
     * @return WebhookSingle
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun storeWebhook(webhookStore: WebhookStore): HttpResponse<WebhookSingle> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody = webhookStore

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/webhooks",
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Submit messages for a webhook.
     * This endpoint will submit any open messages for this webhook. This is an asynchronous operation, so you can&#39;t see the result. Refresh the webhook message and/or the webhook message attempts to see the results. This may take some time if the webhook receiver is slow.
     * @param id The webhook ID.
     * @return void
     */
    open suspend fun submitWebook(id: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/api/v1/webhooks/{id}/submit".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    /**
     * Update existing webhook.
     * Update an existing webhook&#39;s information. If you wish to reset the secret, submit any value as the \&quot;secret\&quot;. Firefly III will take this as a hint and reset the secret of the webhook.
     * @param id The webhook ID.
     * @param webhookUpdate JSON array with updated webhook information. See the model for the exact specifications.
     * @return WebhookSingle
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateWebhook(id: kotlin.String, webhookUpdate: WebhookUpdate): HttpResponse<WebhookSingle> {

        val localVariableAuthNames = listOf<String>("firefly_iii_auth")

        val localVariableBody = webhookUpdate

        val localVariableQuery = mutableMapOf<String, List<String>>()

        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/api/v1/webhooks/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

}
